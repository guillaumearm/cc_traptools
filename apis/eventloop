-- Basic event loop library for computer craft
--
-- Example usage:
--
-- local events = eventloop.new()
--
-- local disposeRedstoneEvent = events.register("redstone", function()
--   print("Redstone signal received!")
-- end)
--
-- events.register("key_up", function(k)
--   if k == keys.q then
--     disposeRedstoneEvent()
--     return events.STOP
--   end
-- end)
--
-- events.runLoop();
local next_eventloop_id = 1;

STOP = '@libeventloop/STOP_HANDLER_SUBSCRIPTION';

function new()
  local api = {}

  local runningLoop = false;
  local eventloop_id = next_eventloop_id;
  next_eventloop_id = next_eventloop_id + 1;

  local handlersCounter = 0;
  local allHandlers = {};

  local runningHandlers = nil;
  local unregisterQueue = {};

  -- used when setTimeout are registered when runningLoop is false
  local nextTimeoutFactoryId = 1;
  local timeoutFactories = {};

  -- used at runtime
  local timeoutHandlersCounter = 0;
  local timeoutHandlers = {};

  -- onStop handlers
  local onStopHandlerCounter = 0;
  local nextOnStopHandlerId = 1;
  local onStopHandlers = {};

  -- onStart handlers
  local onStartHandlers = {}

  local function resetOnStopHandlers()
    onStopHandlerCounter = 0;
    nextOnStopHandlerId = 1;
    onStopHandlers = {};
  end

  local function addOnStopHandler(h)
    local id = nextOnStopHandlerId

    nextOnStopHandlerId = nextOnStopHandlerId + 1;
    onStopHandlerCounter = onStopHandlerCounter + 1;

    onStopHandlers[id] = h;

    return id
  end

  local function execOnStopHandlers()
    for _, h in pairs(onStopHandlers) do
      h()
    end
    resetOnStopHandlers()
  end

  local function getHandlersCounter()
    return timeoutHandlersCounter + handlersCounter;
  end

  local function insertTimeoutHandler(id, handler)
    timeoutHandlers[id] = handler;
    timeoutHandlersCounter = timeoutHandlersCounter + 1
  end

  local function removeTimeoutHandler(id)
    timeoutHandlers[id] = nil;
    timeoutHandlersCounter = timeoutHandlersCounter - 1

    if getHandlersCounter() == 0 then
      api.stopLoop();
    end
  end

  local function resetFactories()
    nextTimeoutFactoryId = 1;
    timeoutFactories = {}
  end

  local function resetAll()
    runningLoop = false;
    handlersCounter = 0;
    allHandlers = {};
    runningHandlers = nil;
    unregisterQueue = {};

    resetFactories();

    for k, _ in pairs(timeoutHandlers) do
      os.cancelTimer(k);
    end

    timeoutHandlersCounter = 0;
    timeoutHandlers = {};

    resetOnStopHandlers()

    onStartHandlers = {}
  end

  local function flushUnregisterQueue()
    if #unregisterQueue == 0 then
      return
    end

    for _, f in pairs(unregisterQueue) do
      f()
    end

    unregisterQueue = {}
  end

  local END_OF_LOOP = '@libeventloop/END_OF_LOOP/' .. eventloop_id

  api.STOP = STOP

  -- stopLoop
  function api.stopLoop()
    if runningLoop then
      os.queueEvent(END_OF_LOOP)
    else
      error("libeventloop error: loop is already stopped")
    end
  end

  -- unregister
  function api.unregister(eventName, handler)
    assert(type(eventName) == 'string', 'bad argument #1 (string expected)')
    assert(type(handler) == 'function', 'bad argument #2 (function expected)')

    local function removeHandler()
      local handlers = allHandlers[eventName]

      if not handlers then
        error("libeventloop error: no handler registered for the '" .. eventName .. "' event")
      end

      if handlers[handler] then
        handlers[handler] = nil
        handlersCounter = handlersCounter - 1;
        if getHandlersCounter() == 0 then
          api.stopLoop();
        end
      end
    end

    if runningHandlers then
      table.insert(unregisterQueue, function()
        return removeHandler()
      end)
      return
    end

    return removeHandler()
  end

  -- register
  function api.register(eventName, handler)
    assert(type(eventName) == 'string', 'bad argument #1 (string expected)')
    assert(type(handler) == 'function', 'bad argument #2 (function expected)')

    if not allHandlers[eventName] then
      allHandlers[eventName] = {}
    end

    local handlers = allHandlers[eventName]
    if handlers[handler] then
      error("libeventloop error: handler already registered for event '" .. eventName .. "'")
    end

    handlers[handler] = handler;
    handlersCounter = handlersCounter + 1;

    return function()
      api.unregister(eventName, handler)
    end
  end

  -- runLoop
  function api.runLoop(noCheckHandlers)
    local shouldCheckHandlers = not noCheckHandlers

    if runningLoop then
      error("libeventloop error: event loop is already ran")
    end

    for _, f in pairs(timeoutFactories) do
      local timerId, h = f()
      insertTimeoutHandler(timerId, h)
    end

    resetFactories();

    if shouldCheckHandlers and getHandlersCounter() == 0 and onStopHandlerCounter == 0 then
      error(
        "libeventloop error: tried to run event loop without handlers (use 'register' and/or 'setTimeout' before 'runLoop')")
    end

    if shouldCheckHandlers and getHandlersCounter() == 0 and onStopHandlerCounter > 0 then
      execOnStopHandlers()
      return
    end

    runningLoop = true;

    for _, h in ipairs(onStartHandlers) do
      h()
    end
    onStartHandlers = {}

    while true do
      local packed = table.pack(os.pullEventRaw())
      local eventName = table.remove(packed, 1)

      if eventName == 'timer' then
        -- setTimeout handlers
        local timerId = packed[1];

        for k, h in pairs(timeoutHandlers) do
          if k == timerId then
            removeTimeoutHandler(k)
            h();
          end
        end
      else
        -- regular event handlers
        local handlers = allHandlers[eventName]
        if handlers then
          runningHandlers = eventName
          for _, handler in pairs(handlers) do
            local result_handler = handler(table.unpack(packed))
            if result_handler == api.STOP then
              api.unregister(eventName, handler)
            end
          end
          runningHandlers = nil
          flushUnregisterQueue()
        end

        if eventName == END_OF_LOOP or eventName == 'terminate' then
          execOnStopHandlers()
          resetAll()
          break
        end
      end
    end
  end

  -- startLoop
  api.startLoop = api.runLoop

  -- setTimeout
  function api.setTimeout(handler, seconds)
    seconds = math.abs(seconds or 0);

    assert(type(handler) == 'function', 'bad argument #1 (function expected)')
    assert(type(seconds) == 'number', 'bad argument #2 (number expected)')

    if runningLoop then
      local timerId = os.startTimer(seconds)

      insertTimeoutHandler(timerId, handler)

      return function()
        -- clearTimeout
        if timeoutHandlers[timerId] then
          removeTimeoutHandler(timerId)
          os.cancelTimer(timerId);
        end
      end
    else
      local timeoutFactoryId = nextTimeoutFactoryId;
      nextTimeoutFactoryId = nextTimeoutFactoryId + 1

      local timerId = nil;

      local factory = function()
        timerId = os.startTimer(seconds)
        return timerId, handler;
      end

      timeoutFactories[timeoutFactoryId] = factory

      return function()
        -- clearTimeout
        if timerId == nil then
          timeoutFactories[timeoutFactoryId] = nil
        elseif timeoutHandlers[timerId] then
          removeTimeoutHandler(timerId)
          os.cancelTimer(timerId);
        end
      end
    end
  end

  -- onStop
  function api.onStop(handler)
    assert(type(handler) == 'function', 'bad argument #1 (function expected)')

    local handlerId = addOnStopHandler(handler);

    return function()
      local h = onStopHandlers[handlerId];
      if h then
        h();
        onStopHandlers[handlerId] = nil
        onStopHandlerCounter = onStopHandlerCounter - 1;
      end
    end
  end

  -- onStart
  function api.onStart(handler)
    assert(type(handler) == 'function', 'bad argument #1 (function expected)');

    if runningLoop then
      handler();
    else
      table.insert(onStartHandlers, handler);
    end
  end

  return api;
end

create = new
